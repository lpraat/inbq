"""
This file is autogenerated via `cargo run --bin inbq_genpy`.
"""

import json
import typing
from dataclasses import dataclass
from typing import (
    Any,
    ClassVar,
    Optional,
    Self,
    TypeAlias,
    get_args,
    get_origin,
    get_type_hints,
)
from types import UnionType, NoneType


class AstNode:
    _PRIMITIVE_TYPES: ClassVar[frozenset[typing.Type[Any]]] = frozenset(
        (bool, str, int, float)
    )
    _GLOBALS: ClassVar[dict[str, Any]] = globals()
    _ENUM_DECODER: dict[str, dict[str, str]] = {
        "Statement": {
            "Query": "Statement_Query",
            "Insert": "Statement_Insert",
            "Delete": "Statement_Delete",
            "Update": "Statement_Update",
            "Truncate": "Statement_Truncate",
            "Merge": "Statement_Merge",
            "DeclareVar": "Statement_DeclareVar",
            "SetVar": "Statement_SetVar",
            "Block": "Statement_Block",
            "CreateTable": "Statement_CreateTable",
            "DropTableStatement": "Statement_DropTableStatement",
        },
        "ParameterizedType": {
            "Array": "ParameterizedType_Array",
            "BigNumeric": "ParameterizedType_BigNumeric",
            "Bool": "ParameterizedType_Bool",
            "Bytes": "ParameterizedType_Bytes",
            "Date": "ParameterizedType_Date",
            "Datetime": "ParameterizedType_Datetime",
            "Float64": "ParameterizedType_Float64",
            "Geography": "ParameterizedType_Geography",
            "Int64": "ParameterizedType_Int64",
            "Interval": "ParameterizedType_Interval",
            "Json": "ParameterizedType_Json",
            "Numeric": "ParameterizedType_Numeric",
            "Range": "ParameterizedType_Range",
            "String": "ParameterizedType_String",
            "Struct": "ParameterizedType_Struct",
            "Time": "ParameterizedType_Time",
            "Timestamp": "ParameterizedType_Timestamp",
        },
        "Type": {
            "Array": "Type_Array",
            "BigNumeric": "Type_BigNumeric",
            "Bool": "Type_Bool",
            "Bytes": "Type_Bytes",
            "Date": "Type_Date",
            "Datetime": "Type_Datetime",
            "Float64": "Type_Float64",
            "Geography": "Type_Geography",
            "Int64": "Type_Int64",
            "Interval": "Type_Interval",
            "Json": "Type_Json",
            "Numeric": "Type_Numeric",
            "Range": "Type_Range",
            "String": "Type_String",
            "Struct": "Type_Struct",
            "Time": "Type_Time",
            "Timestamp": "Type_Timestamp",
        },
        "MergeSource": {
            "Table": "MergeSource_Table",
            "Subquery": "MergeSource_Subquery",
        },
        "Merge": {
            "Update": "Merge_Update",
            "Insert": "Merge_Insert",
            "InsertRow": "Merge_InsertRow",
            "Delete": "Merge_Delete",
        },
        "When": {
            "Matched": "When_Matched",
            "NotMatchedByTarget": "When_NotMatchedByTarget",
            "NotMatchedBySource": "When_NotMatchedBySource",
        },
        "Expr": {
            "Binary": "Expr_Binary",
            "Unary": "Expr_Unary",
            "Grouping": "Expr_Grouping",
            "Array": "Expr_Array",
            "Struct": "Expr_Struct",
            "Identifier": "Expr_Identifier",
            "QuotedIdentifier": "Expr_QuotedIdentifier",
            "String": "Expr_String",
            "Bytes": "Expr_Bytes",
            "Numeric": "Expr_Numeric",
            "BigNumeric": "Expr_BigNumeric",
            "Number": "Expr_Number",
            "Bool": "Expr_Bool",
            "Date": "Expr_Date",
            "Time": "Expr_Time",
            "Datetime": "Expr_Datetime",
            "Timestamp": "Expr_Timestamp",
            "Range": "Expr_Range",
            "Interval": "Expr_Interval",
            "Json": "Expr_Json",
            "Default": "Expr_Default",
            "Null": "Expr_Null",
            "Star": "Expr_Star",
            "Query": "Expr_Query",
            "Case": "Expr_Case",
            "GenericFunction": "Expr_GenericFunction",
            "Function": "Expr_Function",
            "QuantifiedLike": "Expr_QuantifiedLike",
        },
        "IntervalExpr": {
            "Interval": "IntervalExpr_Interval",
            "IntervalRange": "IntervalExpr_IntervalRange",
        },
        "IntervalPart": {
            "Year": "IntervalPart_Year",
            "Quarter": "IntervalPart_Quarter",
            "Month": "IntervalPart_Month",
            "Week": "IntervalPart_Week",
            "Day": "IntervalPart_Day",
            "Hour": "IntervalPart_Hour",
            "Minute": "IntervalPart_Minute",
            "Second": "IntervalPart_Second",
            "Millisecond": "IntervalPart_Millisecond",
            "Microsecond": "IntervalPart_Microsecond",
        },
        "FunctionExpr": {
            "Array": "FunctionExpr_Array",
            "ArrayAgg": "FunctionExpr_ArrayAgg",
            "Concat": "FunctionExpr_Concat",
            "Cast": "FunctionExpr_Cast",
            "Extract": "FunctionExpr_Extract",
            "If": "FunctionExpr_If",
            "SafeCast": "FunctionExpr_SafeCast",
            "CurrentDate": "FunctionExpr_CurrentDate",
            "CurrentTimestamp": "FunctionExpr_CurrentTimestamp",
        },
        "ExtractFunctionPart": {
            "MicroSecond": "ExtractFunctionPart_MicroSecond",
            "MilliSecond": "ExtractFunctionPart_MilliSecond",
            "Second": "ExtractFunctionPart_Second",
            "Minute": "ExtractFunctionPart_Minute",
            "Hour": "ExtractFunctionPart_Hour",
            "DayOfWeek": "ExtractFunctionPart_DayOfWeek",
            "Day": "ExtractFunctionPart_Day",
            "DayOfYear": "ExtractFunctionPart_DayOfYear",
            "Week": "ExtractFunctionPart_Week",
            "WeekWithBegin": "ExtractFunctionPart_WeekWithBegin",
            "IsoWeek": "ExtractFunctionPart_IsoWeek",
            "Month": "ExtractFunctionPart_Month",
            "Quarter": "ExtractFunctionPart_Quarter",
            "Year": "ExtractFunctionPart_Year",
            "IsoYear": "ExtractFunctionPart_IsoYear",
            "Date": "ExtractFunctionPart_Date",
            "Time": "ExtractFunctionPart_Time",
        },
        "WeekBegin": {
            "Sunday": "WeekBegin_Sunday",
            "Monday": "WeekBegin_Monday",
            "Tuesday": "WeekBegin_Tuesday",
            "Wednesday": "WeekBegin_Wednesday",
            "Thursday": "WeekBegin_Thursday",
            "Friday": "WeekBegin_Friday",
            "Saturday": "WeekBegin_Saturday",
        },
        "FunctionAggregateNulls": {
            "Ignore": "FunctionAggregateNulls_Ignore",
            "Respect": "FunctionAggregateNulls_Respect",
        },
        "FunctionAggregateHavingKind": {
            "Max": "FunctionAggregateHavingKind_Max",
            "Min": "FunctionAggregateHavingKind_Min",
        },
        "UnaryOperator": {
            "Plus": "UnaryOperator_Plus",
            "Minus": "UnaryOperator_Minus",
            "BitwiseNot": "UnaryOperator_BitwiseNot",
            "IsNull": "UnaryOperator_IsNull",
            "IsNotNull": "UnaryOperator_IsNotNull",
            "IsTrue": "UnaryOperator_IsTrue",
            "IsNotTrue": "UnaryOperator_IsNotTrue",
            "IsFalse": "UnaryOperator_IsFalse",
            "IsNotFalse": "UnaryOperator_IsNotFalse",
            "Not": "UnaryOperator_Not",
        },
        "BinaryOperator": {
            "BitwiseNot": "BinaryOperator_BitwiseNot",
            "Star": "BinaryOperator_Star",
            "Slash": "BinaryOperator_Slash",
            "Concat": "BinaryOperator_Concat",
            "Plus": "BinaryOperator_Plus",
            "Minus": "BinaryOperator_Minus",
            "BitwiseLeftShift": "BinaryOperator_BitwiseLeftShift",
            "BitwiseRightShift": "BinaryOperator_BitwiseRightShift",
            "BitwiseAnd": "BinaryOperator_BitwiseAnd",
            "BitwiseXor": "BinaryOperator_BitwiseXor",
            "BitwiseOr": "BinaryOperator_BitwiseOr",
            "Equal": "BinaryOperator_Equal",
            "LessThan": "BinaryOperator_LessThan",
            "GreaterThan": "BinaryOperator_GreaterThan",
            "LessThanOrEqualTo": "BinaryOperator_LessThanOrEqualTo",
            "GreaterTHanOrEqualTo": "BinaryOperator_GreaterTHanOrEqualTo",
            "NotEqual": "BinaryOperator_NotEqual",
            "Like": "BinaryOperator_Like",
            "NotLike": "BinaryOperator_NotLike",
            "QuantifiedLike": "BinaryOperator_QuantifiedLike",
            "QuantifiedNotLike": "BinaryOperator_QuantifiedNotLike",
            "Between": "BinaryOperator_Between",
            "NotBetween": "BinaryOperator_NotBetween",
            "In": "BinaryOperator_In",
            "NotIn": "BinaryOperator_NotIn",
            "And": "BinaryOperator_And",
            "Or": "BinaryOperator_Or",
            "ArrayIndex": "BinaryOperator_ArrayIndex",
            "FieldAccess": "BinaryOperator_FieldAccess",
        },
        "LikeQuantifier": {
            "Any": "LikeQuantifier_Any",
            "Some": "LikeQuantifier_Some",
            "All": "LikeQuantifier_All",
        },
        "QuantifiedLikeExprPattern": {
            "ExprList": "QuantifiedLikeExprPattern_ExprList",
            "ArrayUnnest": "QuantifiedLikeExprPattern_ArrayUnnest",
        },
        "QueryExpr": {
            "Grouping": "QueryExpr_Grouping",
            "Select": "QueryExpr_Select",
            "SetSelect": "QueryExpr_SetSelect",
        },
        "SetQueryOperator": {
            "Union": "SetQueryOperator_Union",
            "UnionDistinct": "SetQueryOperator_UnionDistinct",
            "IntersectDistinct": "SetQueryOperator_IntersectDistinct",
            "ExceptDistinct": "SetQueryOperator_ExceptDistinct",
        },
        "OrderBySortDirection": {
            "Asc": "OrderBySortDirection_Asc",
            "Desc": "OrderBySortDirection_Desc",
        },
        "OrderByNulls": {
            "First": "OrderByNulls_First",
            "Last": "OrderByNulls_Last",
        },
        "Cte": {
            "NonRecursive": "Cte_NonRecursive",
            "Recursive": "Cte_Recursive",
        },
        "SelectTableValue": {
            "Struct": "SelectTableValue_Struct",
            "Value": "SelectTableValue_Value",
        },
        "SelectExpr": {
            "Col": "SelectExpr_Col",
            "ColAll": "SelectExpr_ColAll",
            "All": "SelectExpr_All",
        },
        "FromExpr": {
            "Join": "FromExpr_Join",
            "FullJoin": "FromExpr_FullJoin",
            "LeftJoin": "FromExpr_LeftJoin",
            "RightJoin": "FromExpr_RightJoin",
            "CrossJoin": "FromExpr_CrossJoin",
            "Path": "FromExpr_Path",
            "Unnest": "FromExpr_Unnest",
            "GroupingQuery": "FromExpr_GroupingQuery",
            "GroupingFrom": "FromExpr_GroupingFrom",
        },
        "JoinKind": {
            "Inner": "JoinKind_Inner",
            "Left": "JoinKind_Left",
            "Right": "JoinKind_Right",
            "Full": "JoinKind_Full",
        },
        "JoinCondition": {
            "On": "JoinCondition_On",
            "Using": "JoinCondition_Using",
        },
        "GroupByExpr": {
            "Items": "GroupByExpr_Items",
            "All": "GroupByExpr_All",
        },
        "NamedWindowExpr": {
            "Reference": "NamedWindowExpr_Reference",
            "WindowSpec": "NamedWindowExpr_WindowSpec",
        },
        "FrameBound": {
            "UnboundedPreceding": "FrameBound_UnboundedPreceding",
            "Preceding": "FrameBound_Preceding",
            "UnboundedFollowing": "FrameBound_UnboundedFollowing",
            "Following": "FrameBound_Following",
            "CurrentRow": "FrameBound_CurrentRow",
        },
        "WindowFrameKind": {
            "Range": "WindowFrameKind_Range",
            "Rows": "WindowFrameKind_Rows",
        },
        "ParseToken": {
            "Single": "ParseToken_Single",
            "Multiple": "ParseToken_Multiple",
        },
        "TokenType": {
            "LeftParen": "TokenType_LeftParen",
            "RightParen": "TokenType_RightParen",
            "LeftSquare": "TokenType_LeftSquare",
            "RightSquare": "TokenType_RightSquare",
            "Comma": "TokenType_Comma",
            "Dot": "TokenType_Dot",
            "Minus": "TokenType_Minus",
            "Plus": "TokenType_Plus",
            "BitwiseNot": "TokenType_BitwiseNot",
            "BitwiseOr": "TokenType_BitwiseOr",
            "BitwiseAnd": "TokenType_BitwiseAnd",
            "BitwiseXor": "TokenType_BitwiseXor",
            "BitwiseRightShift": "TokenType_BitwiseRightShift",
            "BitwiseLeftShift": "TokenType_BitwiseLeftShift",
            "Colon": "TokenType_Colon",
            "Semicolon": "TokenType_Semicolon",
            "Slash": "TokenType_Slash",
            "Star": "TokenType_Star",
            "Tick": "TokenType_Tick",
            "ConcatOperator": "TokenType_ConcatOperator",
            "Bang": "TokenType_Bang",
            "BangEqual": "TokenType_BangEqual",
            "Equal": "TokenType_Equal",
            "NotEqual": "TokenType_NotEqual",
            "Greater": "TokenType_Greater",
            "GreaterEqual": "TokenType_GreaterEqual",
            "Less": "TokenType_Less",
            "LessEqual": "TokenType_LessEqual",
            "QuotedIdentifier": "TokenType_QuotedIdentifier",
            "Identifier": "TokenType_Identifier",
            "String": "TokenType_String",
            "RawString": "TokenType_RawString",
            "Bytes": "TokenType_Bytes",
            "RawBytes": "TokenType_RawBytes",
            "Number": "TokenType_Number",
            "Eof": "TokenType_Eof",
            "All": "TokenType_All",
            "And": "TokenType_And",
            "Any": "TokenType_Any",
            "Array": "TokenType_Array",
            "As": "TokenType_As",
            "Asc": "TokenType_Asc",
            "AssertRowsModified": "TokenType_AssertRowsModified",
            "At": "TokenType_At",
            "Between": "TokenType_Between",
            "By": "TokenType_By",
            "Case": "TokenType_Case",
            "Cast": "TokenType_Cast",
            "Collate": "TokenType_Collate",
            "Contains": "TokenType_Contains",
            "Create": "TokenType_Create",
            "Cross": "TokenType_Cross",
            "Cube": "TokenType_Cube",
            "Current": "TokenType_Current",
            "Default": "TokenType_Default",
            "Define": "TokenType_Define",
            "Desc": "TokenType_Desc",
            "Distinct": "TokenType_Distinct",
            "Else": "TokenType_Else",
            "End": "TokenType_End",
            "Enum": "TokenType_Enum",
            "Escape": "TokenType_Escape",
            "Except": "TokenType_Except",
            "Exclude": "TokenType_Exclude",
            "Exists": "TokenType_Exists",
            "Extract": "TokenType_Extract",
            "False": "TokenType_False",
            "Fetch": "TokenType_Fetch",
            "Following": "TokenType_Following",
            "For": "TokenType_For",
            "From": "TokenType_From",
            "Full": "TokenType_Full",
            "Group": "TokenType_Group",
            "Grouping": "TokenType_Grouping",
            "Groups": "TokenType_Groups",
            "Hash": "TokenType_Hash",
            "Having": "TokenType_Having",
            "If": "TokenType_If",
            "Ignore": "TokenType_Ignore",
            "In": "TokenType_In",
            "Inner": "TokenType_Inner",
            "Intersect": "TokenType_Intersect",
            "Interval": "TokenType_Interval",
            "Into": "TokenType_Into",
            "Is": "TokenType_Is",
            "Join": "TokenType_Join",
            "Lateral": "TokenType_Lateral",
            "Left": "TokenType_Left",
            "Like": "TokenType_Like",
            "Limit": "TokenType_Limit",
            "Lookup": "TokenType_Lookup",
            "Merge": "TokenType_Merge",
            "Natural": "TokenType_Natural",
            "New": "TokenType_New",
            "No": "TokenType_No",
            "Not": "TokenType_Not",
            "Null": "TokenType_Null",
            "Nulls": "TokenType_Nulls",
            "Of": "TokenType_Of",
            "On": "TokenType_On",
            "Or": "TokenType_Or",
            "Order": "TokenType_Order",
            "Outer": "TokenType_Outer",
            "Over": "TokenType_Over",
            "Partition": "TokenType_Partition",
            "Preceding": "TokenType_Preceding",
            "Proto": "TokenType_Proto",
            "Qualify": "TokenType_Qualify",
            "Range": "TokenType_Range",
            "Recursive": "TokenType_Recursive",
            "Respect": "TokenType_Respect",
            "Right": "TokenType_Right",
            "Rollup": "TokenType_Rollup",
            "Rows": "TokenType_Rows",
            "Select": "TokenType_Select",
            "Set": "TokenType_Set",
            "Some": "TokenType_Some",
            "Struct": "TokenType_Struct",
            "Tablesample": "TokenType_Tablesample",
            "Then": "TokenType_Then",
            "To": "TokenType_To",
            "Treat": "TokenType_Treat",
            "True": "TokenType_True",
            "Union": "TokenType_Union",
            "Unnest": "TokenType_Unnest",
            "Using": "TokenType_Using",
            "When": "TokenType_When",
            "Where": "TokenType_Where",
            "Window": "TokenType_Window",
            "With": "TokenType_With",
            "Within": "TokenType_Within",
        },
    }

    @classmethod
    def from_json_str(cls, json_str: str) -> Self:
        return cls.from_dict(json.loads(json_str))

    @classmethod
    def from_dict(cls, data: dict) -> Self:
        return cls._instantiate_type_from_data(cls, data)

    @classmethod
    def _decode_enum_variant(cls, first_type: typing.Type, data: dict) -> Any:
        if "_" in first_type.__name__:
            # Find the py_class of the enum variant
            # from args which contains all the variants
            enum_name = first_type.__name__.split("_")[0]

            if type(data) is str and data in cls._ENUM_DECODER[enum_name]:
                # This is a unit variant (whose py_class does not have any attribute, e.g., TokenType_Minus)
                return cls._GLOBALS[cls._ENUM_DECODER[enum_name][data]]()

            variant_in_data = list(data)[0]
            clz = cls._GLOBALS[cls._ENUM_DECODER[enum_name][variant_in_data]]
            return clz.from_dict(data[variant_in_data])
        else:
            return cls._instantiate_type_from_data(first_type, data)

    @classmethod
    def _instantiate_type_from_data(cls, ty: typing.Type, data: dict) -> Any:
        if ty in cls._PRIMITIVE_TYPES:
            return ty(data)

        elif (
            get_origin(ty) is typing.Union
            and len(get_args(ty)) > 1
            and get_args(ty)[-1] is NoneType
        ):
            if data is None:
                return None
            return cls._instantiate_type_from_data(get_args(ty)[:-1], data)

        elif isinstance(ty, tuple):
            first_type = ty[0]
            return cls._decode_enum_variant(first_type, data)

        elif get_origin(ty) is UnionType:
            first_type = get_args(ty)[0]
            return cls._decode_enum_variant(first_type, data)

        elif get_origin(ty) is list:
            return [cls._instantiate_type_from_data(get_args(ty)[0], el) for el in data]

        elif "ast_nodes" in cls.__module__:
            ty_hints = {
                k: v for k, v in get_type_hints(ty).items() if not k.startswith("_")
            }
            cls_dict = {}

            if "_" in cls.__name__ and len(ty_hints) == 1 and "value" in ty_hints:
                cls_dict["value"] = cls._instantiate_type_from_data(
                    ty_hints["value"], data
                )
            else:
                for field, field_ty in ty_hints.items():
                    original_field = field
                    if field.endswith("_"):
                        field = field[:-1]

                    cls_dict[original_field] = cls._instantiate_type_from_data(
                        field_ty, data[field]
                    )

            return ty(**cls_dict)
        else:
            raise NotImplementedError(f"Unexpected {ty=} with {data=}.")


@dataclass
class Ast(AstNode):
    statements: "list[Statement]"


@dataclass
class StatementsBlock(AstNode):
    statements: "list[Statement]"
    exception_statements: "Optional[list[Statement]]"


@dataclass
class DeclareVarStatement(AstNode):
    var_names: "list[ParseToken]"
    type_: "Optional[ParameterizedType]"
    default: "Optional[Expr]"


@dataclass
class SetVarStatement(AstNode):
    var_names: "list[ParseToken]"
    exprs: "list[Expr]"


@dataclass
class CreateTableStatement(AstNode):
    name: "ParseToken"
    schema: "Optional[list[ColumnSchema]]"
    replace: "bool"
    is_temporary: "bool"
    if_not_exists: "bool"
    query: "Optional[QueryExpr]"


@dataclass
class DropTableStatement(AstNode):
    name: "ParseToken"
    if_exists: "bool"


@dataclass
class ColumnSchema(AstNode):
    name: "ParseToken"
    type_: "ParameterizedType"


@dataclass
class StructParameterizedFieldType(AstNode):
    name: "ParseToken"
    type_: "ParameterizedType"


@dataclass
class StructFieldType(AstNode):
    name: "Optional[ParseToken]"
    type_: "Type"


@dataclass
class QueryStatement(AstNode):
    query: "QueryExpr"


@dataclass
class InsertStatement(AstNode):
    table: "ParseToken"
    columns: "Optional[list[ParseToken]]"
    values: "Optional[list[Expr]]"
    query: "Optional[QueryExpr]"


@dataclass
class DeleteStatement(AstNode):
    table: "ParseToken"
    alias: "Optional[ParseToken]"
    cond: "Expr"


@dataclass
class UpdateItem(AstNode):
    column: "ParseToken"
    expr: "Expr"


@dataclass
class UpdateStatement(AstNode):
    table: "ParseToken"
    alias: "Optional[ParseToken]"
    update_items: "list[UpdateItem]"
    from_: "Optional[From]"
    where: "Where"


@dataclass
class TruncateStatement(AstNode):
    table: "ParseToken"


@dataclass
class MergeStatement(AstNode):
    target_table: "ParseToken"
    target_alias: "Optional[ParseToken]"
    source: "MergeSource"
    source_alias: "Optional[ParseToken]"
    condition: "Expr"
    whens: "list[When]"


@dataclass
class MergeUpdate(AstNode):
    update_items: "list[UpdateItem]"


@dataclass
class MergeInsert(AstNode):
    columns: "Optional[list[ParseToken]]"
    values: "list[Expr]"


@dataclass
class WhenMatched(AstNode):
    search_condition: "Optional[Expr]"
    merge: "Merge"


@dataclass
class WhenNotMatchedByTarget(AstNode):
    search_condition: "Optional[Expr]"
    merge: "Merge"


@dataclass
class WhenNotMatchedBySource(AstNode):
    search_condition: "Optional[Expr]"
    merge: "Merge"


@dataclass
class CaseExpr(AstNode):
    case_: "Optional[Expr]"
    when_thens: "list[WhenThen]"
    else_: "Optional[Expr]"


@dataclass
class WhenThen(AstNode):
    when: "Expr"
    then: "Expr"


@dataclass
class RangeExpr(AstNode):
    type_: "Type"
    value: "str"


@dataclass
class ExtractFunctionExpr(AstNode):
    part: "ExtractFunctionPart"
    expr: "Expr"


@dataclass
class CurrentDateFunctionExpr(AstNode):
    timezone: "Optional[Expr]"


@dataclass
class ArrayAggFunctionExpr(AstNode):
    arg: "GenericFunctionExprArg"
    over: "Optional[NamedWindowExpr]"


@dataclass
class ArrayFunctionExpr(AstNode):
    query: "QueryExpr"


@dataclass
class ConcatFunctionExpr(AstNode):
    values: "list[Expr]"


@dataclass
class CastFunctionExpr(AstNode):
    expr: "Expr"
    type_: "ParameterizedType"
    format: "Optional[Expr]"


@dataclass
class SafeCastFunctionExpr(AstNode):
    expr: "Expr"
    type_: "ParameterizedType"
    format: "Optional[Expr]"


@dataclass
class IfFunctionExpr(AstNode):
    condition: "Expr"
    true_result: "Expr"
    false_result: "Expr"


@dataclass
class GenericFunctionExpr(AstNode):
    name: "ParseToken"
    arguments: "list[GenericFunctionExprArg]"
    over: "Optional[NamedWindowExpr]"


@dataclass
class GenericFunctionExprArg(AstNode):
    expr: "Expr"
    aggregate: "Optional[FunctionAggregate]"


@dataclass
class FunctionAggregate(AstNode):
    distinct: "bool"
    nulls: "Optional[FunctionAggregateNulls]"
    having: "Optional[FunctionAggregateHaving]"
    order_by: "Optional[list[FunctionAggregateOrderBy]]"
    limit: "Optional[Expr]"


@dataclass
class FunctionAggregateOrderBy(AstNode):
    expr: "Expr"
    sort_direction: "Optional[OrderBySortDirection]"


@dataclass
class FunctionAggregateHaving(AstNode):
    expr: "Expr"
    kind: "FunctionAggregateHavingKind"


@dataclass
class UnaryExpr(AstNode):
    operator: "UnaryOperator"
    right: "Expr"


@dataclass
class BinaryExpr(AstNode):
    left: "Expr"
    operator: "BinaryOperator"
    right: "Expr"


@dataclass
class QuantifiedLikeExpr(AstNode):
    quantifier: "LikeQuantifier"
    pattern: "QuantifiedLikeExprPattern"


@dataclass
class GroupingExpr(AstNode):
    expr: "Expr"


@dataclass
class ArrayExpr(AstNode):
    type_: "Optional[Type]"
    exprs: "list[Expr]"


@dataclass
class StructExpr(AstNode):
    type_: "Optional[Type]"
    fields: "list[StructField]"


@dataclass
class StructField(AstNode):
    expr: "Expr"
    alias: "Optional[ParseToken]"


@dataclass
class GroupingQueryExpr(AstNode):
    with_: "Optional[With]"
    query: "QueryExpr"
    order_by: "Optional[OrderBy]"
    limit: "Optional[Limit]"


@dataclass
class SelectQueryExpr(AstNode):
    with_: "Optional[With]"
    select: "Select"
    order_by: "Optional[OrderBy]"
    limit: "Optional[Limit]"


@dataclass
class SetSelectQueryExpr(AstNode):
    with_: "Optional[With]"
    left_query: "QueryExpr"
    set_operator: "SetQueryOperator"
    right_query: "QueryExpr"
    order_by: "Optional[OrderBy]"
    limit: "Optional[Limit]"


@dataclass
class OrderBy(AstNode):
    exprs: "list[OrderByExpr]"


@dataclass
class OrderByExpr(AstNode):
    expr: "Expr"
    sort_direction: "Optional[OrderBySortDirection]"
    nulls: "Optional[OrderByNulls]"


@dataclass
class Limit(AstNode):
    count: "Expr"
    offset: "Optional[Expr]"


@dataclass
class With(AstNode):
    ctes: "list[Cte]"


@dataclass
class NonRecursiveCte(AstNode):
    name: "ParseToken"
    query: "QueryExpr"


@dataclass
class RecursiveCte(AstNode):
    name: "ParseToken"
    base_query: "QueryExpr"
    recursive_query: "QueryExpr"


@dataclass
class Select(AstNode):
    distinct: "bool"
    table_value: "Optional[SelectTableValue]"
    exprs: "list[SelectExpr]"
    from_: "Optional[From]"
    where: "Optional[Where]"
    group_by: "Optional[GroupBy]"
    having: "Optional[Having]"
    qualify: "Optional[Qualify]"
    window: "Optional[Window]"


@dataclass
class SelectColExpr(AstNode):
    expr: "Expr"
    alias: "Optional[ParseToken]"


@dataclass
class SelectColAllExpr(AstNode):
    expr: "Expr"
    except_: "Optional[list[ParseToken]]"


@dataclass
class SelectAllExpr(AstNode):
    except_: "Optional[list[ParseToken]]"


@dataclass
class From(AstNode):
    expr: "FromExpr"


@dataclass
class CrossJoinExpr(AstNode):
    left: "FromExpr"
    right: "FromExpr"


@dataclass
class JoinExpr(AstNode):
    kind: "JoinKind"
    left: "FromExpr"
    right: "FromExpr"
    cond: "JoinCondition"


@dataclass
class UnnestExpr(AstNode):
    array: "Expr"
    alias: "Optional[ParseToken]"
    with_offset: "bool"
    offset_alias: "Optional[ParseToken]"


@dataclass
class PathExpr(AstNode):
    expr: "ParseToken"


@dataclass
class FromPathExpr(AstNode):
    path: "PathExpr"
    alias: "Optional[ParseToken]"


@dataclass
class GroupingFromExpr(AstNode):
    query: "FromExpr"


@dataclass
class FromGroupingQueryExpr(AstNode):
    query: "QueryExpr"
    alias: "Optional[ParseToken]"


@dataclass
class Where(AstNode):
    expr: "Expr"


@dataclass
class GroupBy(AstNode):
    expr: "GroupByExpr"


@dataclass
class Having(AstNode):
    expr: "Expr"


@dataclass
class Qualify(AstNode):
    expr: "Expr"


@dataclass
class Window(AstNode):
    named_windows: "list[NamedWindow]"


@dataclass
class WindowOrderByExpr(AstNode):
    expr: "Expr"
    asc_desc: "Optional[OrderBySortDirection]"


@dataclass
class NamedWindow(AstNode):
    name: "ParseToken"
    window: "NamedWindowExpr"


@dataclass
class WindowSpec(AstNode):
    window_name: "Optional[ParseToken]"
    partition_by: "Optional[list[Expr]]"
    order_by: "Optional[list[WindowOrderByExpr]]"
    frame: "Optional[WindowFrame]"


@dataclass
class WindowFrame(AstNode):
    kind: "WindowFrameKind"
    start: "Optional[FrameBound]"
    end: "Optional[FrameBound]"


@dataclass
class Token(AstNode):
    kind: "TokenType"
    lexeme: "str"
    line: "int"
    col: "int"


@dataclass
class Statement_Query(AstNode):
    value: "QueryStatement"


@dataclass
class Statement_Insert(AstNode):
    value: "InsertStatement"


@dataclass
class Statement_Delete(AstNode):
    value: "DeleteStatement"


@dataclass
class Statement_Update(AstNode):
    value: "UpdateStatement"


@dataclass
class Statement_Truncate(AstNode):
    value: "TruncateStatement"


@dataclass
class Statement_Merge(AstNode):
    value: "MergeStatement"


@dataclass
class Statement_DeclareVar(AstNode):
    value: "DeclareVarStatement"


@dataclass
class Statement_SetVar(AstNode):
    value: "SetVarStatement"


@dataclass
class Statement_Block(AstNode):
    value: "StatementsBlock"


@dataclass
class Statement_CreateTable(AstNode):
    value: "CreateTableStatement"


@dataclass
class Statement_DropTableStatement(AstNode):
    value: "DropTableStatement"


Statement: TypeAlias = "Statement_Query | Statement_Insert | Statement_Delete | Statement_Update | Statement_Truncate | Statement_Merge | Statement_DeclareVar | Statement_SetVar | Statement_Block | Statement_CreateTable | Statement_DropTableStatement"


@dataclass
class ParameterizedType_Array(AstNode):
    type_: "ParameterizedType"


@dataclass
class ParameterizedType_BigNumeric(AstNode):
    precision: "Optional[str]"
    scale: "Optional[str]"


@dataclass
class ParameterizedType_Bool(AstNode): ...


@dataclass
class ParameterizedType_Bytes(AstNode):
    max_length: "Optional[str]"


@dataclass
class ParameterizedType_Date(AstNode): ...


@dataclass
class ParameterizedType_Datetime(AstNode): ...


@dataclass
class ParameterizedType_Float64(AstNode): ...


@dataclass
class ParameterizedType_Geography(AstNode): ...


@dataclass
class ParameterizedType_Int64(AstNode): ...


@dataclass
class ParameterizedType_Interval(AstNode): ...


@dataclass
class ParameterizedType_Json(AstNode): ...


@dataclass
class ParameterizedType_Numeric(AstNode):
    precision: "Optional[str]"
    scale: "Optional[str]"


@dataclass
class ParameterizedType_Range(AstNode):
    type_: "ParameterizedType"


@dataclass
class ParameterizedType_String(AstNode):
    max_length: "Optional[str]"


@dataclass
class ParameterizedType_Struct(AstNode):
    fields: "list[StructParameterizedFieldType]"


@dataclass
class ParameterizedType_Time(AstNode): ...


@dataclass
class ParameterizedType_Timestamp(AstNode): ...


ParameterizedType: TypeAlias = "ParameterizedType_Array | ParameterizedType_BigNumeric | ParameterizedType_Bool | ParameterizedType_Bytes | ParameterizedType_Date | ParameterizedType_Datetime | ParameterizedType_Float64 | ParameterizedType_Geography | ParameterizedType_Int64 | ParameterizedType_Interval | ParameterizedType_Json | ParameterizedType_Numeric | ParameterizedType_Range | ParameterizedType_String | ParameterizedType_Struct | ParameterizedType_Time | ParameterizedType_Timestamp"


@dataclass
class Type_Array(AstNode):
    type_: "Type"


@dataclass
class Type_BigNumeric(AstNode): ...


@dataclass
class Type_Bool(AstNode): ...


@dataclass
class Type_Bytes(AstNode): ...


@dataclass
class Type_Date(AstNode): ...


@dataclass
class Type_Datetime(AstNode): ...


@dataclass
class Type_Float64(AstNode): ...


@dataclass
class Type_Geography(AstNode): ...


@dataclass
class Type_Int64(AstNode): ...


@dataclass
class Type_Interval(AstNode): ...


@dataclass
class Type_Json(AstNode): ...


@dataclass
class Type_Numeric(AstNode): ...


@dataclass
class Type_Range(AstNode):
    type_: "Type"


@dataclass
class Type_String(AstNode): ...


@dataclass
class Type_Struct(AstNode):
    fields: "list[StructFieldType]"


@dataclass
class Type_Time(AstNode): ...


@dataclass
class Type_Timestamp(AstNode): ...


Type: TypeAlias = "Type_Array | Type_BigNumeric | Type_Bool | Type_Bytes | Type_Date | Type_Datetime | Type_Float64 | Type_Geography | Type_Int64 | Type_Interval | Type_Json | Type_Numeric | Type_Range | Type_String | Type_Struct | Type_Time | Type_Timestamp"


@dataclass
class MergeSource_Table(AstNode):
    value: "ParseToken"


@dataclass
class MergeSource_Subquery(AstNode):
    value: "QueryExpr"


MergeSource: TypeAlias = "MergeSource_Table | MergeSource_Subquery"


@dataclass
class Merge_Update(AstNode):
    value: "MergeUpdate"


@dataclass
class Merge_Insert(AstNode):
    value: "MergeInsert"


@dataclass
class Merge_InsertRow(AstNode): ...


@dataclass
class Merge_Delete(AstNode): ...


Merge: TypeAlias = "Merge_Update | Merge_Insert | Merge_InsertRow | Merge_Delete"


@dataclass
class When_Matched(AstNode):
    value: "WhenMatched"


@dataclass
class When_NotMatchedByTarget(AstNode):
    value: "WhenNotMatchedByTarget"


@dataclass
class When_NotMatchedBySource(AstNode):
    value: "WhenNotMatchedBySource"


When: TypeAlias = "When_Matched | When_NotMatchedByTarget | When_NotMatchedBySource"


@dataclass
class Expr_Binary(AstNode):
    value: "BinaryExpr"


@dataclass
class Expr_Unary(AstNode):
    value: "UnaryExpr"


@dataclass
class Expr_Grouping(AstNode):
    value: "GroupingExpr"


@dataclass
class Expr_Array(AstNode):
    value: "ArrayExpr"


@dataclass
class Expr_Struct(AstNode):
    value: "StructExpr"


@dataclass
class Expr_Identifier(AstNode):
    value: "str"


@dataclass
class Expr_QuotedIdentifier(AstNode):
    value: "str"


@dataclass
class Expr_String(AstNode):
    value: "str"


@dataclass
class Expr_Bytes(AstNode):
    value: "str"


@dataclass
class Expr_Numeric(AstNode):
    value: "str"


@dataclass
class Expr_BigNumeric(AstNode):
    value: "str"


@dataclass
class Expr_Number(AstNode):
    value: "str"


@dataclass
class Expr_Bool(AstNode):
    value: "bool"


@dataclass
class Expr_Date(AstNode):
    value: "str"


@dataclass
class Expr_Time(AstNode):
    value: "str"


@dataclass
class Expr_Datetime(AstNode):
    value: "str"


@dataclass
class Expr_Timestamp(AstNode):
    value: "str"


@dataclass
class Expr_Range(AstNode):
    value: "RangeExpr"


@dataclass
class Expr_Interval(AstNode):
    value: "IntervalExpr"


@dataclass
class Expr_Json(AstNode):
    value: "str"


@dataclass
class Expr_Default(AstNode): ...


@dataclass
class Expr_Null(AstNode): ...


@dataclass
class Expr_Star(AstNode): ...


@dataclass
class Expr_Query(AstNode):
    value: "QueryExpr"


@dataclass
class Expr_Case(AstNode):
    value: "CaseExpr"


@dataclass
class Expr_GenericFunction(AstNode):
    value: "GenericFunctionExpr"


@dataclass
class Expr_Function(AstNode):
    value: "FunctionExpr"


@dataclass
class Expr_QuantifiedLike(AstNode):
    value: "QuantifiedLikeExpr"


Expr: TypeAlias = "Expr_Binary | Expr_Unary | Expr_Grouping | Expr_Array | Expr_Struct | Expr_Identifier | Expr_QuotedIdentifier | Expr_String | Expr_Bytes | Expr_Numeric | Expr_BigNumeric | Expr_Number | Expr_Bool | Expr_Date | Expr_Time | Expr_Datetime | Expr_Timestamp | Expr_Range | Expr_Interval | Expr_Json | Expr_Default | Expr_Null | Expr_Star | Expr_Query | Expr_Case | Expr_GenericFunction | Expr_Function | Expr_QuantifiedLike"


@dataclass
class IntervalExpr_Interval(AstNode):
    value: "Expr"
    part: "IntervalPart"


@dataclass
class IntervalExpr_IntervalRange(AstNode):
    value: "str"
    start_part: "IntervalPart"
    end_part: "IntervalPart"


IntervalExpr: TypeAlias = "IntervalExpr_Interval | IntervalExpr_IntervalRange"


@dataclass
class IntervalPart_Year(AstNode): ...


@dataclass
class IntervalPart_Quarter(AstNode): ...


@dataclass
class IntervalPart_Month(AstNode): ...


@dataclass
class IntervalPart_Week(AstNode): ...


@dataclass
class IntervalPart_Day(AstNode): ...


@dataclass
class IntervalPart_Hour(AstNode): ...


@dataclass
class IntervalPart_Minute(AstNode): ...


@dataclass
class IntervalPart_Second(AstNode): ...


@dataclass
class IntervalPart_Millisecond(AstNode): ...


@dataclass
class IntervalPart_Microsecond(AstNode): ...


IntervalPart: TypeAlias = "IntervalPart_Year | IntervalPart_Quarter | IntervalPart_Month | IntervalPart_Week | IntervalPart_Day | IntervalPart_Hour | IntervalPart_Minute | IntervalPart_Second | IntervalPart_Millisecond | IntervalPart_Microsecond"


@dataclass
class FunctionExpr_Array(AstNode):
    value: "ArrayFunctionExpr"


@dataclass
class FunctionExpr_ArrayAgg(AstNode):
    value: "ArrayAggFunctionExpr"


@dataclass
class FunctionExpr_Concat(AstNode):
    value: "ConcatFunctionExpr"


@dataclass
class FunctionExpr_Cast(AstNode):
    value: "CastFunctionExpr"


@dataclass
class FunctionExpr_Extract(AstNode):
    value: "ExtractFunctionExpr"


@dataclass
class FunctionExpr_If(AstNode):
    value: "IfFunctionExpr"


@dataclass
class FunctionExpr_SafeCast(AstNode):
    value: "SafeCastFunctionExpr"


@dataclass
class FunctionExpr_CurrentDate(AstNode):
    value: "CurrentDateFunctionExpr"


@dataclass
class FunctionExpr_CurrentTimestamp(AstNode): ...


FunctionExpr: TypeAlias = "FunctionExpr_Array | FunctionExpr_ArrayAgg | FunctionExpr_Concat | FunctionExpr_Cast | FunctionExpr_Extract | FunctionExpr_If | FunctionExpr_SafeCast | FunctionExpr_CurrentDate | FunctionExpr_CurrentTimestamp"


@dataclass
class ExtractFunctionPart_MicroSecond(AstNode): ...


@dataclass
class ExtractFunctionPart_MilliSecond(AstNode): ...


@dataclass
class ExtractFunctionPart_Second(AstNode): ...


@dataclass
class ExtractFunctionPart_Minute(AstNode): ...


@dataclass
class ExtractFunctionPart_Hour(AstNode): ...


@dataclass
class ExtractFunctionPart_DayOfWeek(AstNode): ...


@dataclass
class ExtractFunctionPart_Day(AstNode): ...


@dataclass
class ExtractFunctionPart_DayOfYear(AstNode): ...


@dataclass
class ExtractFunctionPart_Week(AstNode): ...


@dataclass
class ExtractFunctionPart_WeekWithBegin(AstNode):
    value: "WeekBegin"


@dataclass
class ExtractFunctionPart_IsoWeek(AstNode): ...


@dataclass
class ExtractFunctionPart_Month(AstNode): ...


@dataclass
class ExtractFunctionPart_Quarter(AstNode): ...


@dataclass
class ExtractFunctionPart_Year(AstNode): ...


@dataclass
class ExtractFunctionPart_IsoYear(AstNode): ...


@dataclass
class ExtractFunctionPart_Date(AstNode): ...


@dataclass
class ExtractFunctionPart_Time(AstNode): ...


ExtractFunctionPart: TypeAlias = "ExtractFunctionPart_MicroSecond | ExtractFunctionPart_MilliSecond | ExtractFunctionPart_Second | ExtractFunctionPart_Minute | ExtractFunctionPart_Hour | ExtractFunctionPart_DayOfWeek | ExtractFunctionPart_Day | ExtractFunctionPart_DayOfYear | ExtractFunctionPart_Week | ExtractFunctionPart_WeekWithBegin | ExtractFunctionPart_IsoWeek | ExtractFunctionPart_Month | ExtractFunctionPart_Quarter | ExtractFunctionPart_Year | ExtractFunctionPart_IsoYear | ExtractFunctionPart_Date | ExtractFunctionPart_Time"


@dataclass
class WeekBegin_Sunday(AstNode): ...


@dataclass
class WeekBegin_Monday(AstNode): ...


@dataclass
class WeekBegin_Tuesday(AstNode): ...


@dataclass
class WeekBegin_Wednesday(AstNode): ...


@dataclass
class WeekBegin_Thursday(AstNode): ...


@dataclass
class WeekBegin_Friday(AstNode): ...


@dataclass
class WeekBegin_Saturday(AstNode): ...


WeekBegin: TypeAlias = "WeekBegin_Sunday | WeekBegin_Monday | WeekBegin_Tuesday | WeekBegin_Wednesday | WeekBegin_Thursday | WeekBegin_Friday | WeekBegin_Saturday"


@dataclass
class FunctionAggregateNulls_Ignore(AstNode): ...


@dataclass
class FunctionAggregateNulls_Respect(AstNode): ...


FunctionAggregateNulls: TypeAlias = (
    "FunctionAggregateNulls_Ignore | FunctionAggregateNulls_Respect"
)


@dataclass
class FunctionAggregateHavingKind_Max(AstNode): ...


@dataclass
class FunctionAggregateHavingKind_Min(AstNode): ...


FunctionAggregateHavingKind: TypeAlias = (
    "FunctionAggregateHavingKind_Max | FunctionAggregateHavingKind_Min"
)


@dataclass
class UnaryOperator_Plus(AstNode): ...


@dataclass
class UnaryOperator_Minus(AstNode): ...


@dataclass
class UnaryOperator_BitwiseNot(AstNode): ...


@dataclass
class UnaryOperator_IsNull(AstNode): ...


@dataclass
class UnaryOperator_IsNotNull(AstNode): ...


@dataclass
class UnaryOperator_IsTrue(AstNode): ...


@dataclass
class UnaryOperator_IsNotTrue(AstNode): ...


@dataclass
class UnaryOperator_IsFalse(AstNode): ...


@dataclass
class UnaryOperator_IsNotFalse(AstNode): ...


@dataclass
class UnaryOperator_Not(AstNode): ...


UnaryOperator: TypeAlias = "UnaryOperator_Plus | UnaryOperator_Minus | UnaryOperator_BitwiseNot | UnaryOperator_IsNull | UnaryOperator_IsNotNull | UnaryOperator_IsTrue | UnaryOperator_IsNotTrue | UnaryOperator_IsFalse | UnaryOperator_IsNotFalse | UnaryOperator_Not"


@dataclass
class BinaryOperator_BitwiseNot(AstNode): ...


@dataclass
class BinaryOperator_Star(AstNode): ...


@dataclass
class BinaryOperator_Slash(AstNode): ...


@dataclass
class BinaryOperator_Concat(AstNode): ...


@dataclass
class BinaryOperator_Plus(AstNode): ...


@dataclass
class BinaryOperator_Minus(AstNode): ...


@dataclass
class BinaryOperator_BitwiseLeftShift(AstNode): ...


@dataclass
class BinaryOperator_BitwiseRightShift(AstNode): ...


@dataclass
class BinaryOperator_BitwiseAnd(AstNode): ...


@dataclass
class BinaryOperator_BitwiseXor(AstNode): ...


@dataclass
class BinaryOperator_BitwiseOr(AstNode): ...


@dataclass
class BinaryOperator_Equal(AstNode): ...


@dataclass
class BinaryOperator_LessThan(AstNode): ...


@dataclass
class BinaryOperator_GreaterThan(AstNode): ...


@dataclass
class BinaryOperator_LessThanOrEqualTo(AstNode): ...


@dataclass
class BinaryOperator_GreaterTHanOrEqualTo(AstNode): ...


@dataclass
class BinaryOperator_NotEqual(AstNode): ...


@dataclass
class BinaryOperator_Like(AstNode): ...


@dataclass
class BinaryOperator_NotLike(AstNode): ...


@dataclass
class BinaryOperator_QuantifiedLike(AstNode): ...


@dataclass
class BinaryOperator_QuantifiedNotLike(AstNode): ...


@dataclass
class BinaryOperator_Between(AstNode): ...


@dataclass
class BinaryOperator_NotBetween(AstNode): ...


@dataclass
class BinaryOperator_In(AstNode): ...


@dataclass
class BinaryOperator_NotIn(AstNode): ...


@dataclass
class BinaryOperator_And(AstNode): ...


@dataclass
class BinaryOperator_Or(AstNode): ...


@dataclass
class BinaryOperator_ArrayIndex(AstNode): ...


@dataclass
class BinaryOperator_FieldAccess(AstNode): ...


BinaryOperator: TypeAlias = "BinaryOperator_BitwiseNot | BinaryOperator_Star | BinaryOperator_Slash | BinaryOperator_Concat | BinaryOperator_Plus | BinaryOperator_Minus | BinaryOperator_BitwiseLeftShift | BinaryOperator_BitwiseRightShift | BinaryOperator_BitwiseAnd | BinaryOperator_BitwiseXor | BinaryOperator_BitwiseOr | BinaryOperator_Equal | BinaryOperator_LessThan | BinaryOperator_GreaterThan | BinaryOperator_LessThanOrEqualTo | BinaryOperator_GreaterTHanOrEqualTo | BinaryOperator_NotEqual | BinaryOperator_Like | BinaryOperator_NotLike | BinaryOperator_QuantifiedLike | BinaryOperator_QuantifiedNotLike | BinaryOperator_Between | BinaryOperator_NotBetween | BinaryOperator_In | BinaryOperator_NotIn | BinaryOperator_And | BinaryOperator_Or | BinaryOperator_ArrayIndex | BinaryOperator_FieldAccess"


@dataclass
class LikeQuantifier_Any(AstNode): ...


@dataclass
class LikeQuantifier_Some(AstNode): ...


@dataclass
class LikeQuantifier_All(AstNode): ...


LikeQuantifier: TypeAlias = (
    "LikeQuantifier_Any | LikeQuantifier_Some | LikeQuantifier_All"
)


@dataclass
class QuantifiedLikeExprPattern_ExprList(AstNode):
    exprs: "list[Expr]"


@dataclass
class QuantifiedLikeExprPattern_ArrayUnnest(AstNode):
    expr: "Expr"


QuantifiedLikeExprPattern: TypeAlias = (
    "QuantifiedLikeExprPattern_ExprList | QuantifiedLikeExprPattern_ArrayUnnest"
)


@dataclass
class QueryExpr_Grouping(AstNode):
    value: "GroupingQueryExpr"


@dataclass
class QueryExpr_Select(AstNode):
    value: "SelectQueryExpr"


@dataclass
class QueryExpr_SetSelect(AstNode):
    value: "SetSelectQueryExpr"


QueryExpr: TypeAlias = "QueryExpr_Grouping | QueryExpr_Select | QueryExpr_SetSelect"


@dataclass
class SetQueryOperator_Union(AstNode): ...


@dataclass
class SetQueryOperator_UnionDistinct(AstNode): ...


@dataclass
class SetQueryOperator_IntersectDistinct(AstNode): ...


@dataclass
class SetQueryOperator_ExceptDistinct(AstNode): ...


SetQueryOperator: TypeAlias = "SetQueryOperator_Union | SetQueryOperator_UnionDistinct | SetQueryOperator_IntersectDistinct | SetQueryOperator_ExceptDistinct"


@dataclass
class OrderBySortDirection_Asc(AstNode): ...


@dataclass
class OrderBySortDirection_Desc(AstNode): ...


OrderBySortDirection: TypeAlias = "OrderBySortDirection_Asc | OrderBySortDirection_Desc"


@dataclass
class OrderByNulls_First(AstNode): ...


@dataclass
class OrderByNulls_Last(AstNode): ...


OrderByNulls: TypeAlias = "OrderByNulls_First | OrderByNulls_Last"


@dataclass
class Cte_NonRecursive(AstNode):
    value: "NonRecursiveCte"


@dataclass
class Cte_Recursive(AstNode):
    value: "RecursiveCte"


Cte: TypeAlias = "Cte_NonRecursive | Cte_Recursive"


@dataclass
class SelectTableValue_Struct(AstNode): ...


@dataclass
class SelectTableValue_Value(AstNode): ...


SelectTableValue: TypeAlias = "SelectTableValue_Struct | SelectTableValue_Value"


@dataclass
class SelectExpr_Col(AstNode):
    value: "SelectColExpr"


@dataclass
class SelectExpr_ColAll(AstNode):
    value: "SelectColAllExpr"


@dataclass
class SelectExpr_All(AstNode):
    value: "SelectAllExpr"


SelectExpr: TypeAlias = "SelectExpr_Col | SelectExpr_ColAll | SelectExpr_All"


@dataclass
class FromExpr_Join(AstNode):
    value: "JoinExpr"


@dataclass
class FromExpr_FullJoin(AstNode):
    value: "JoinExpr"


@dataclass
class FromExpr_LeftJoin(AstNode):
    value: "JoinExpr"


@dataclass
class FromExpr_RightJoin(AstNode):
    value: "JoinExpr"


@dataclass
class FromExpr_CrossJoin(AstNode):
    value: "CrossJoinExpr"


@dataclass
class FromExpr_Path(AstNode):
    value: "FromPathExpr"


@dataclass
class FromExpr_Unnest(AstNode):
    value: "UnnestExpr"


@dataclass
class FromExpr_GroupingQuery(AstNode):
    value: "FromGroupingQueryExpr"


@dataclass
class FromExpr_GroupingFrom(AstNode):
    value: "GroupingFromExpr"


FromExpr: TypeAlias = "FromExpr_Join | FromExpr_FullJoin | FromExpr_LeftJoin | FromExpr_RightJoin | FromExpr_CrossJoin | FromExpr_Path | FromExpr_Unnest | FromExpr_GroupingQuery | FromExpr_GroupingFrom"


@dataclass
class JoinKind_Inner(AstNode): ...


@dataclass
class JoinKind_Left(AstNode): ...


@dataclass
class JoinKind_Right(AstNode): ...


@dataclass
class JoinKind_Full(AstNode): ...


JoinKind: TypeAlias = "JoinKind_Inner | JoinKind_Left | JoinKind_Right | JoinKind_Full"


@dataclass
class JoinCondition_On(AstNode):
    value: "Expr"


@dataclass
class JoinCondition_Using(AstNode):
    value: "list[ParseToken]"


JoinCondition: TypeAlias = "JoinCondition_On | JoinCondition_Using"


@dataclass
class GroupByExpr_Items(AstNode):
    value: "list[Expr]"


@dataclass
class GroupByExpr_All(AstNode): ...


GroupByExpr: TypeAlias = "GroupByExpr_Items | GroupByExpr_All"


@dataclass
class NamedWindowExpr_Reference(AstNode):
    value: "ParseToken"


@dataclass
class NamedWindowExpr_WindowSpec(AstNode):
    value: "WindowSpec"


NamedWindowExpr: TypeAlias = "NamedWindowExpr_Reference | NamedWindowExpr_WindowSpec"


@dataclass
class FrameBound_UnboundedPreceding(AstNode): ...


@dataclass
class FrameBound_Preceding(AstNode):
    value: "str"


@dataclass
class FrameBound_UnboundedFollowing(AstNode): ...


@dataclass
class FrameBound_Following(AstNode):
    value: "str"


@dataclass
class FrameBound_CurrentRow(AstNode): ...


FrameBound: TypeAlias = "FrameBound_UnboundedPreceding | FrameBound_Preceding | FrameBound_UnboundedFollowing | FrameBound_Following | FrameBound_CurrentRow"


@dataclass
class WindowFrameKind_Range(AstNode): ...


@dataclass
class WindowFrameKind_Rows(AstNode): ...


WindowFrameKind: TypeAlias = "WindowFrameKind_Range | WindowFrameKind_Rows"


@dataclass
class ParseToken_Single(AstNode):
    value: "Token"


@dataclass
class ParseToken_Multiple(AstNode):
    value: "list[Token]"


ParseToken: TypeAlias = "ParseToken_Single | ParseToken_Multiple"


@dataclass
class TokenType_LeftParen(AstNode): ...


@dataclass
class TokenType_RightParen(AstNode): ...


@dataclass
class TokenType_LeftSquare(AstNode): ...


@dataclass
class TokenType_RightSquare(AstNode): ...


@dataclass
class TokenType_Comma(AstNode): ...


@dataclass
class TokenType_Dot(AstNode): ...


@dataclass
class TokenType_Minus(AstNode): ...


@dataclass
class TokenType_Plus(AstNode): ...


@dataclass
class TokenType_BitwiseNot(AstNode): ...


@dataclass
class TokenType_BitwiseOr(AstNode): ...


@dataclass
class TokenType_BitwiseAnd(AstNode): ...


@dataclass
class TokenType_BitwiseXor(AstNode): ...


@dataclass
class TokenType_BitwiseRightShift(AstNode): ...


@dataclass
class TokenType_BitwiseLeftShift(AstNode): ...


@dataclass
class TokenType_Colon(AstNode): ...


@dataclass
class TokenType_Semicolon(AstNode): ...


@dataclass
class TokenType_Slash(AstNode): ...


@dataclass
class TokenType_Star(AstNode): ...


@dataclass
class TokenType_Tick(AstNode): ...


@dataclass
class TokenType_ConcatOperator(AstNode): ...


@dataclass
class TokenType_Bang(AstNode): ...


@dataclass
class TokenType_BangEqual(AstNode): ...


@dataclass
class TokenType_Equal(AstNode): ...


@dataclass
class TokenType_NotEqual(AstNode): ...


@dataclass
class TokenType_Greater(AstNode): ...


@dataclass
class TokenType_GreaterEqual(AstNode): ...


@dataclass
class TokenType_Less(AstNode): ...


@dataclass
class TokenType_LessEqual(AstNode): ...


@dataclass
class TokenType_QuotedIdentifier(AstNode):
    value: "str"


@dataclass
class TokenType_Identifier(AstNode):
    value: "str"


@dataclass
class TokenType_String(AstNode):
    value: "str"


@dataclass
class TokenType_RawString(AstNode):
    value: "str"


@dataclass
class TokenType_Bytes(AstNode):
    value: "str"


@dataclass
class TokenType_RawBytes(AstNode):
    value: "str"


@dataclass
class TokenType_Number(AstNode):
    value: "str"


@dataclass
class TokenType_Eof(AstNode): ...


@dataclass
class TokenType_All(AstNode): ...


@dataclass
class TokenType_And(AstNode): ...


@dataclass
class TokenType_Any(AstNode): ...


@dataclass
class TokenType_Array(AstNode): ...


@dataclass
class TokenType_As(AstNode): ...


@dataclass
class TokenType_Asc(AstNode): ...


@dataclass
class TokenType_AssertRowsModified(AstNode): ...


@dataclass
class TokenType_At(AstNode): ...


@dataclass
class TokenType_Between(AstNode): ...


@dataclass
class TokenType_By(AstNode): ...


@dataclass
class TokenType_Case(AstNode): ...


@dataclass
class TokenType_Cast(AstNode): ...


@dataclass
class TokenType_Collate(AstNode): ...


@dataclass
class TokenType_Contains(AstNode): ...


@dataclass
class TokenType_Create(AstNode): ...


@dataclass
class TokenType_Cross(AstNode): ...


@dataclass
class TokenType_Cube(AstNode): ...


@dataclass
class TokenType_Current(AstNode): ...


@dataclass
class TokenType_Default(AstNode): ...


@dataclass
class TokenType_Define(AstNode): ...


@dataclass
class TokenType_Desc(AstNode): ...


@dataclass
class TokenType_Distinct(AstNode): ...


@dataclass
class TokenType_Else(AstNode): ...


@dataclass
class TokenType_End(AstNode): ...


@dataclass
class TokenType_Enum(AstNode): ...


@dataclass
class TokenType_Escape(AstNode): ...


@dataclass
class TokenType_Except(AstNode): ...


@dataclass
class TokenType_Exclude(AstNode): ...


@dataclass
class TokenType_Exists(AstNode): ...


@dataclass
class TokenType_Extract(AstNode): ...


@dataclass
class TokenType_False(AstNode): ...


@dataclass
class TokenType_Fetch(AstNode): ...


@dataclass
class TokenType_Following(AstNode): ...


@dataclass
class TokenType_For(AstNode): ...


@dataclass
class TokenType_From(AstNode): ...


@dataclass
class TokenType_Full(AstNode): ...


@dataclass
class TokenType_Group(AstNode): ...


@dataclass
class TokenType_Grouping(AstNode): ...


@dataclass
class TokenType_Groups(AstNode): ...


@dataclass
class TokenType_Hash(AstNode): ...


@dataclass
class TokenType_Having(AstNode): ...


@dataclass
class TokenType_If(AstNode): ...


@dataclass
class TokenType_Ignore(AstNode): ...


@dataclass
class TokenType_In(AstNode): ...


@dataclass
class TokenType_Inner(AstNode): ...


@dataclass
class TokenType_Intersect(AstNode): ...


@dataclass
class TokenType_Interval(AstNode): ...


@dataclass
class TokenType_Into(AstNode): ...


@dataclass
class TokenType_Is(AstNode): ...


@dataclass
class TokenType_Join(AstNode): ...


@dataclass
class TokenType_Lateral(AstNode): ...


@dataclass
class TokenType_Left(AstNode): ...


@dataclass
class TokenType_Like(AstNode): ...


@dataclass
class TokenType_Limit(AstNode): ...


@dataclass
class TokenType_Lookup(AstNode): ...


@dataclass
class TokenType_Merge(AstNode): ...


@dataclass
class TokenType_Natural(AstNode): ...


@dataclass
class TokenType_New(AstNode): ...


@dataclass
class TokenType_No(AstNode): ...


@dataclass
class TokenType_Not(AstNode): ...


@dataclass
class TokenType_Null(AstNode): ...


@dataclass
class TokenType_Nulls(AstNode): ...


@dataclass
class TokenType_Of(AstNode): ...


@dataclass
class TokenType_On(AstNode): ...


@dataclass
class TokenType_Or(AstNode): ...


@dataclass
class TokenType_Order(AstNode): ...


@dataclass
class TokenType_Outer(AstNode): ...


@dataclass
class TokenType_Over(AstNode): ...


@dataclass
class TokenType_Partition(AstNode): ...


@dataclass
class TokenType_Preceding(AstNode): ...


@dataclass
class TokenType_Proto(AstNode): ...


@dataclass
class TokenType_Qualify(AstNode): ...


@dataclass
class TokenType_Range(AstNode): ...


@dataclass
class TokenType_Recursive(AstNode): ...


@dataclass
class TokenType_Respect(AstNode): ...


@dataclass
class TokenType_Right(AstNode): ...


@dataclass
class TokenType_Rollup(AstNode): ...


@dataclass
class TokenType_Rows(AstNode): ...


@dataclass
class TokenType_Select(AstNode): ...


@dataclass
class TokenType_Set(AstNode): ...


@dataclass
class TokenType_Some(AstNode): ...


@dataclass
class TokenType_Struct(AstNode): ...


@dataclass
class TokenType_Tablesample(AstNode): ...


@dataclass
class TokenType_Then(AstNode): ...


@dataclass
class TokenType_To(AstNode): ...


@dataclass
class TokenType_Treat(AstNode): ...


@dataclass
class TokenType_True(AstNode): ...


@dataclass
class TokenType_Union(AstNode): ...


@dataclass
class TokenType_Unnest(AstNode): ...


@dataclass
class TokenType_Using(AstNode): ...


@dataclass
class TokenType_When(AstNode): ...


@dataclass
class TokenType_Where(AstNode): ...


@dataclass
class TokenType_Window(AstNode): ...


@dataclass
class TokenType_With(AstNode): ...


@dataclass
class TokenType_Within(AstNode): ...


TokenType: TypeAlias = "TokenType_LeftParen | TokenType_RightParen | TokenType_LeftSquare | TokenType_RightSquare | TokenType_Comma | TokenType_Dot | TokenType_Minus | TokenType_Plus | TokenType_BitwiseNot | TokenType_BitwiseOr | TokenType_BitwiseAnd | TokenType_BitwiseXor | TokenType_BitwiseRightShift | TokenType_BitwiseLeftShift | TokenType_Colon | TokenType_Semicolon | TokenType_Slash | TokenType_Star | TokenType_Tick | TokenType_ConcatOperator | TokenType_Bang | TokenType_BangEqual | TokenType_Equal | TokenType_NotEqual | TokenType_Greater | TokenType_GreaterEqual | TokenType_Less | TokenType_LessEqual | TokenType_QuotedIdentifier | TokenType_Identifier | TokenType_String | TokenType_RawString | TokenType_Bytes | TokenType_RawBytes | TokenType_Number | TokenType_Eof | TokenType_All | TokenType_And | TokenType_Any | TokenType_Array | TokenType_As | TokenType_Asc | TokenType_AssertRowsModified | TokenType_At | TokenType_Between | TokenType_By | TokenType_Case | TokenType_Cast | TokenType_Collate | TokenType_Contains | TokenType_Create | TokenType_Cross | TokenType_Cube | TokenType_Current | TokenType_Default | TokenType_Define | TokenType_Desc | TokenType_Distinct | TokenType_Else | TokenType_End | TokenType_Enum | TokenType_Escape | TokenType_Except | TokenType_Exclude | TokenType_Exists | TokenType_Extract | TokenType_False | TokenType_Fetch | TokenType_Following | TokenType_For | TokenType_From | TokenType_Full | TokenType_Group | TokenType_Grouping | TokenType_Groups | TokenType_Hash | TokenType_Having | TokenType_If | TokenType_Ignore | TokenType_In | TokenType_Inner | TokenType_Intersect | TokenType_Interval | TokenType_Into | TokenType_Is | TokenType_Join | TokenType_Lateral | TokenType_Left | TokenType_Like | TokenType_Limit | TokenType_Lookup | TokenType_Merge | TokenType_Natural | TokenType_New | TokenType_No | TokenType_Not | TokenType_Null | TokenType_Nulls | TokenType_Of | TokenType_On | TokenType_Or | TokenType_Order | TokenType_Outer | TokenType_Over | TokenType_Partition | TokenType_Preceding | TokenType_Proto | TokenType_Qualify | TokenType_Range | TokenType_Recursive | TokenType_Respect | TokenType_Right | TokenType_Rollup | TokenType_Rows | TokenType_Select | TokenType_Set | TokenType_Some | TokenType_Struct | TokenType_Tablesample | TokenType_Then | TokenType_To | TokenType_Treat | TokenType_True | TokenType_Union | TokenType_Unnest | TokenType_Using | TokenType_When | TokenType_Where | TokenType_Window | TokenType_With | TokenType_Within"
