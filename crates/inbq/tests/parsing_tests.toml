[[tests]]
sql = """
select *
from `project-id.dataset.table`
"""

[[tests]]
sql = """
select
    columnA,
    column-a,
    `287column`,
from
    my-project.mydataset.mytable,
    mydataset.mytable,
    `dataset.inventory`,
    my-table,
    mytable,
    `287mytable`
"""

[[tests]]
sql = """
select
  'it\\'s',
  "it's",
  'Title: "Boy"',
  '''Title:"Boy"''',
  '''two
  lines''',
  r"abc+",
  r'''abc+''',
  r\"\"\"abc+\"\"\",
  r'f\\(abc,(.*),def\\)',
  B"abc",
  B'''abc''',
  b\"\"\"abc\"\"\",
  br'abc+',
  RB"abc+",
  RB'''abc''',
  b'\\x48\\x65\\x6c\\x6c\\x6f'
"""

[[tests]]
sql = """
select
    --this is a comment
    'foo' as foo,
    "bar" as bar,
    32.1E4+5 as pi,
    123.456e-67 as b,
    .1E4 as c,
    +58. as d,
    4e2 as e,
    +37 as f,
    -52 as g
from `project.dataset.table`
/* this is multiline comment
aaaa
bbbb
*/
where 1=1
order by c desc
"""

[[tests]]
sql = """
SELECT
    NUMERIC "123",
    BIGNUMERIC '-9.876e-3',
    DATE '2014-09-27',
    DATETIME '2014-09-27T12:30:00.45',
    TIMESTAMP '2014-09-27 12:30:00.45-08',
    RANGE<TIMESTAMP> '[2020-10-01 12:00:00+08, 2020-12-31 12:00:00+08)',
    RANGE<`datetime`> '[2020-10-01 12:00:00+08, 2020-12-31 12:00:00+08)',
    RANGE<DATE> '[UNBOUNDED, UNBOUNDED)',
    INTERVAL 25 HOUR,
    INTERVAL 24 `HOUR`,
    INTERVAL -5 DAY,
    INTERVAL '8 20 17' MONTH TO HOUR,
    INTERVAL '8 20 17' `MONTH` TO HOUR,
    JSON '{"foo": "bar"}'
"""

[[tests]]
sql = """
SELECT
    NUMERIC,
    BIGNUMERIC,
    DATE,
    DATETIME,
    TIMESTAMP,
    JSON,
"""

[[tests]]
sql = """
select null is not null
"""

[[tests]]
sql = """
select null is null
"""

[[tests]]
sql = """
select 1 + @num, @baz, @@time_zone, @@script.job_id
"""

[[tests]]
sql = """
select "foo" "bar" r"baz"
"""

[[tests]]
sql = """
select "foo"
/*comment*/"bar"
"""

[[tests]]
sql = """
select b"foo" rb"bar" b"baz"
"""

[[tests]]
sql = """
SELECT 1 IS DISTINCT FROM 2
"""

[[tests]]
sql = """
SELECT NULL IS NOT DISTINCT FROM NULL
"""

[[tests]]
sql = """
SELECT (NULL IS NOT DISTINCT FROM NULL) is true
"""

[[tests]]
sql = """
SELECT "a"||"b"||"c"
"""

[[tests]]
sql = """
SELECT * FROM Words WHERE value IN UNNEST(['Secure', 'Clarity']);
"""

[[tests]]
sql = """
SELECT WITH(a AS '123',               -- a is '123'
            b AS CONCAT(a, '456'),    -- b is '123456'
            c AS '789',               -- c is '789'
            CONCAT(b, c)) AS result;  -- b + c is '123456789
"""

[[test]]
sql = """
SELECT WITH(a AS RAND(), a - a);
"""

[[test]]
sql = """
SELECT WITH(s AS SUM(input), c AS COUNT(input), s/c)
FROM UNNEST([1.0, 2.0, 3.0]) AS input;
"""

[[tests]]
sql = """
WITH Words AS
 (SELECT 'Intend with clarity.' as value UNION ALL
  SELECT 'Secure with intention.' UNION ALL
  SELECT 'Clarity and security.')
SELECT * FROM Words WHERE value LIKE ANY ('Intend%', '%intention%');
"""

[[tests]]
sql = """
WITH Words AS
 (SELECT 'Intend with clarity.' as value UNION ALL
  SELECT 'Secure with intention.' UNION ALL
  SELECT 'Clarity and security.')
SELECT * FROM Words WHERE value LIKE ANY UNNEST(['%ion%', '%and%']);
"""

[[tests]]
sql = """
select
  * except (id1, id2)
from table
"""

[[tests]]
sql = """
select tmp.s.x[0]
from tmp
"""

[[tests]]
sql = """
SELECT ARRAY(SELECT AS STRUCT 1 a, 2 b)
"""

[[tests]]
sql = """
SELECT AS VALUE STRUCT(1 AS a, 2 AS b) xyz
"""

[[tests]]
sql = """
with tmp as (with inner_tmp as (select 1 as x) select * from inner_tmp)
select * from tmp
"""

[[tests]]
sql = """
with tmp as (with inner_tmp as (select 1 as x) select * from inner_tmp)
select *
"""

[[tests]]
sql = """
with tmp as (select 1 as x), tmp2 as (select 2 as y union all (select 2 as y))
select *
from tmp inner join tmp d using (x) left join tmp as dd on dd.x = d.x
"""

[[tests]]
sql = """
with tmp as (select 1 as x), tmp2 as (select 2 as x)
select (select tmp.x from tmp2) from tmp
"""

[[tests]]
sql = """
with tmp as (select 1 as x), tmp2 as (select 2 as x)
select
  (with tmp3 as (select x from tmp2) select * from tmp3)
from tmp
"""

[[tests]]
sql = """
WITH RECURSIVE T1 AS ( (SELECT 1 AS n) UNION ALL (SELECT n + 1 AS n FROM T1 WHERE n < 3) )
SELECT n FROM T1
"""

[[tests]]
sql = """
SELECT 1 AS one_digit
UNION ALL
SELECT 2 AS one_digit;
"""

[[tests]]
sql = """
SELECT x, y
FROM (SELECT 1 AS x, true AS y UNION ALL
      SELECT 9, true UNION ALL
      SELECT NULL, false)
ORDER BY x NULLS LAST;
"""

[[tests]]
sql = """
SELECT *
  FROM `bigquery-public-data.samples.shakespeare` AS s
  JOIN mydataset.names_by_year(1950) AS n
  ON n.name = s.word
"""

[[tests]]
sql = """
WITH my_orders AS (
    SELECT 1 AS sales, "apple" AS item, 0.99 AS price
    UNION ALL
    SELECT 2, "banana", 0.49
    UNION ALL
    SELECT 5, "apple", 0.99)
SELECT *
FROM mydataset.compute_sales(TABLE my_orders, "apple");
"""

[[tests]]
sql = """
SELECT *
FROM mydataset.compute_sales(TABLE `proj.dat.orders`, "apple");
"""

[[tests]]
sql = """
SELECT Roster.LastName, TeamMascot.Mascot
FROM Roster FULL JOIN TeamMascot ON Roster.SchoolID = TeamMascot.SchoolID;
"""

[[tests]]
sql = """
SELECT * FROM UNNEST ([10,20,30]) as numbers WITH OFFSET;
"""

[[tests]]
sql = """
SELECT *
FROM UNNEST(
  ARRAY<
  STRUCT<
      x INT64,
      y STRING,
      z STRUCT<a INT64, b INT64>>>[
      (1, 'foo', (10, 11)),
      (3, 'bar', (20, 21))]);
"""

[[tests]]
sql = """
SELECT *, struct_value
FROM UNNEST(
ARRAY<
  STRUCT<
  x INT64,
  y STRING>>[
  (1, 'foo'),
  (3, 'bar')]) AS struct_value;
"""

[[tests]]
sql = """
SELECT
  [1,2,3],
  ARRAY[1,2,3][0],
  ARRAY<ARRAY<int64>>[1,2],
  ARRAY<`INTERVAL`>[INTERVAL 1 day],
  ARRAY<RANGE<DATE>>[RANGE<DATE> '[UNBOUNDED, UNBOUNDED)']
"""

[[tests]]
sql = """
WITH Coordinates AS (SELECT [1,2] AS position)
SELECT results FROM Coordinates, UNNEST(Coordinates.position) AS results;
"""

[[tests]]
sql = """
WITH Coordinates AS (SELECT [1,2] AS position)
SELECT results FROM Coordinates, Coordinates.position AS results;
"""

[[tests]]
sql = """
SELECT
      ARRAY<Array<Array<int64>>>[[[1,2]]],
      1>>4,
      3<<2>>3,
"""

[[tests]]
sql = """
select
  array<struct<int64, array<int64>>>[struct(1, [1,2,3])],
  array<struct<`int64`, array<`int64`>>>[struct(1, [1,2,3])]
"""

[[tests]]
sql = """
select
  STRUCT(1,2,3),
  STRUCT(1 AS a, 'abc' AS b),
  STRUCT<date>("2011-05-05"),
  STRUCT<`date`>("2011-05-05"),
  STRUCT<x int64>(5 AS x)  -- should be an error, just not a syntax one
"""

[[tests]]
sql = """
SELECT ARRAY<STRUCT<warehouse STRING, state string>>
    [('warehouse #1', 'WA'),
     ('warehouse #2', 'CA'),
     ('warehouse #3', 'WA')] col
"""

[[tests]]
sql = """
with tmp as (SELECT struct([1,2,3] as x, 2 as y) as s)
select tmp.s.x[0]
from tmp
"""

[[tests]]
sql = """
with tmp as (SELECT struct([1,2,3] as x, 2 as y) as s)
select tmp.s.* except (y)
from tmp
"""

[[tests]]
sql = """
select
    concat("foo", "bar"),
    concat(tbl.c, ' ', 3)
from tbl
"""

[[tests]]
sql = """
select
    CAST('2016-02-01' AS DATE),
    CAST(b'\\x48\\x65\\x6c\\x6c\\x6f' AS STRING FORMAT (select "ASCII")),
    SAFE_CAST("apple" AS INT64) AS not_a_number;
"""

[[tests]]
sql = """
select
    CASE
      WHEN SAFE_CAST(CPU_COUNT AS INT64) IS NOT NULL THEN SAFE_CAST(CPU_COUNT AS INT64)
    END
"""

[[tests]]
sql = """
SELECT IF(true,1,0)
"""

[[tests]]
sql = """
SELECT EXTRACT(HOUR FROM DATETIME(2008, 12, 25, 15, 30, 00)) as hour;
"""

[[tests]]
sql = """
SELECT EXTRACT(WEEK(MONDAY) FROM DATETIME(2008, 12, 25, 15, 30, 00)) as hour;
"""

[[tests]]
sql = """
SELECT EXTRACT(`WEEK`(`MONDAY`) FROM DATETIME(2008, 12, 25, 15, 30, 00)) as hour;
"""

[[tests]]
sql = """
SELECT COUNT(*)
"""

[[tests]]
sql = """
SELECT `COUNT`(*)
"""

[[tests]]
sql = """
SELECT DATE_TRUNC(DATE '2008-12-25', MONTH) AS month;
"""

[[tests]]
sql = """
SELECT DATE_DIFF(DATE '2010-07-07', DATE '2008-12-25', DAY) AS days_diff;
"""

[[tests]]
sql = """
select DATETIME_TRUNC(DATETIME "2008-12-25 15:30:00", DAY) as truncated
"""

[[tests]]
sql = """
select DATETIME_DIFF(DATETIME "2010-07-07 10:20:00", DATETIME "2008-12-25 15:30:00", DAY) as difference
"""

[[tests]]
sql = """
select TIMESTAMP_TRUNC(TIMESTAMP "2008-12-25 15:30:00+00", DAY, "UTC") AS utc
"""

[[tests]]
sql = """
select TIMESTAMP_DIFF(TIMESTAMP "2010-07-07 10:20:00+00", TIMESTAMP "2008-12-25 15:30:00+00", HOUR) AS hours;
"""

[[tests]]
sql = """
select TIME_TRUNC(TIME "15:30:00", HOUR) as truncated;
"""

[[tets]]
sql = """
select TIME_DIFF(TIME "15:30:00", TIME "14:35:00", MINUTE) as difference;
"""

[[tests]]
sql = """
SELECT ARRAY_AGG(x) AS array_agg FROM UNNEST([2, 1,-2, 3, -2, 1, 2]) AS x;
"""

[[tests]]
sql = """
SELECT
  x,
  ARRAY_AGG(x) OVER (ORDER BY ABS(x)) AS array_agg
FROM UNNEST([2, 1, -2, 3, -2, 1, 2]) AS x;
"""

[[tests]]
sql = """
SELECT ARRAY_AGG(x IGNORE NULLS) AS array_agg
FROM UNNEST([NULL, 1, -2, 3, -2, 1, NULL]) AS x
"""

[[tests]]
sql = """
SELECT * FROM
  Produce
  PIVOT(SUM(sales) FOR quarter IN ('Q1', 'Q2', 'Q3', 'Q4'))
  P_ALIAS
"""

[[tests]]
sql = """
SELECT * FROM
  (SELECT product, sales, quarter FROM Produce)
  PIVOT(SUM(sales) AS total_sales, COUNT(*) AS num_records FOR quarter IN ('Q1', 'Q2'))
"""

[[tests]]
sql = """
SELECT * FROM Produce
UNPIVOT(sales FOR quarter IN (Q1, Q2, Q3, Q4))
UP_ALIAS
"""

[[tests]]
sql = """
SELECT * FROM Produce
UNPIVOT(
  (first_half_sales, second_half_sales)
  FOR semesters
  IN ((Q1, Q2) AS 'semester_1', (Q3, Q4) AS 'semester_2'))
"""

[[tests]]
sql = """
SELECT book, LAST_VALUE(book)OVER (ORDER BY year)
FROM Library;
"""

[[tests]]
sql = """
SELECT book, LAST_VALUE(book)
  OVER (
    ORDER BY year
    RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
FROM Library;
"""

[[tests]]
sql = """
SELECT
  last_value(x RESPECT NULLS) OVER() AS foo,
  last_value(x ignore nulls) OVER() AS foo,
FROM UNNEST([0, 3, NULL, 1, 2]) AS x LIMIT 1;
"""

[[tests]]
sql = """
SELECT item, purchases, category, LAST_VALUE(item)
  OVER (d) AS most_popular
FROM Produce
WINDOW
  a AS (PARTITION BY category),
  b AS (a ORDER BY purchases),
  c AS (b ROWS BETWEEN 2 PRECEDING AND 2 FOLLOWING),
  d AS (c);
"""

[[tests]]
sql = """
SELECT item, purchases, category, LAST_VALUE(item)
  OVER (c ROWS BETWEEN 2 PRECEDING AND 2 FOLLOWING) AS most_popular
FROM Produce
WINDOW
  a AS (PARTITION BY category),
  b AS (a ORDER BY purchases),
  c AS b
"""

[[tests]]
sql = """
SELECT ANY_VALUE(year HAVING MAX inches) AS any_year_with_max_inches FROM Precipitation;
"""

[[tests]]
sql = """
SELECT
  x,
  AVG(x) OVER (ORDER BY x ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) AS avg
FROM UNNEST([0, 2, 4, 4, 5]) AS x;
"""

[[tests]]
sql = """
select 1 + case x when x > 0 then 1 else 2 end;
"""

[[tests]]
sql = """
SELECT
    case
        when x > 0 THEN 'high'
        WHEN x < 0 THEN 'low'
    ELSE 'zero' END AS BAR
"""

[[tests]]
sql = """
select 1 + case when true then 1 else 2 end
"""

[[tests]]
sql = """
select case when true then 1 end
"""

[[tests]]
sql = """
select
  current_date,
  `current_date`,
  `current_date`(),
  current_date('America/Los_Angeles'),
  current_timestamp,
  `current_timestamp`,
  `current_timestamp`()
"""

[[tests]]
sql = """
SELECT 'apple' AS example, RIGHT('apple', 3) AS right_example
"""

[[tests]]
sql = """
SELECT b'apple' AS example, RIGHT(b'apple', 3) AS right_example
"""

[[tests]]
sql = """
INSERT dataset.Inventory (product, quantity)
VALUES('top load washer', 10),
      ('front load washer', 20),
      ('dryer', 30),
      ('refrigerator', 10),
      ('microwave', 20),
      (DEFAULT, 30),
      ('oven', 5);
"""

[[tests]]
sql = """
select * from dataset.Inventory
"""

[[tests]]
sql = """
DELETE dataset.Inventory
WHERE quantity = 0
"""

[[tests]]
sql = """
DELETE dataset.Inventory i
WHERE i.product NOT IN (SELECT product from dataset.NewArrivals)
"""

[[tests]]
sql = """
UPDATE dataset.Inventory
SET quantity = quantity - 10,
    supply_constrained = DEFAULT
WHERE product like '%washer%'
"""

[[tests]]
sql = """
UPDATE dataset.Inventory
SET quantity = quantity +
  (SELECT quantity FROM dataset.NewArrivals
   WHERE Inventory.product = NewArrivals.product),
    supply_constrained = false
WHERE product IN (SELECT product FROM dataset.NewArrivals)
"""

[[tests]]
sql = """
UPDATE dataset.Inventory i
SET quantity = i.quantity + n.quantity,
    supply_constrained = false
FROM dataset.NewArrivals n
WHERE i.product = n.product
"""

[[tests]]
sql = """
update tmp as alias_tmp
set alias_tmp.z = (select z from D limit 1)
where true;
"""

[[tests]]
sql = """
TRUNCATE TABLE dataset.Inventory
"""

[[tests]]
sql = """
MERGE dataset.DetailedInventory T
USING dataset.Inventory S
ON T.product = S.product
WHEN NOT MATCHED AND quantity < 20 THEN
  INSERT(product, quantity, supply_constrained, comments)
  VALUES(product, quantity, true, ARRAY<STRUCT<created DATE, comment STRING>>[(DATE('2016-01-01'), 'comment1')])
WHEN NOT MATCHED THEN
  INSERT(product, quantity, supply_constrained)
  VALUES(product, quantity, false)
"""

[[tests]]
sql = """
MERGE dataset.Inventory T
USING dataset.NewArrivals S
ON T.product = S.product
WHEN MATCHED THEN
  UPDATE SET quantity = T.quantity + S.quantity
WHEN NOT MATCHED THEN
  INSERT (product, quantity) VALUES(product, quantity)
"""

[[tests]]
sql = """
MERGE dataset.NewArrivals T
USING (SELECT * FROM dataset.NewArrivals WHERE warehouse <> 'warehouse #2') S
ON T.product = S.product
WHEN MATCHED AND T.warehouse = 'warehouse #1' THEN
  UPDATE SET quantity = T.quantity + 20
WHEN MATCHED THEN
  DELETE
"""

[[tests]]
sql = """
MERGE dataset.Inventory T
USING dataset.NewArrivals S
ON FALSE
WHEN NOT MATCHED AND product LIKE '%washer%' THEN
  INSERT (product, quantity) VALUES(product, quantity)
WHEN NOT MATCHED BY SOURCE AND product LIKE '%washer%' THEN
  DELETE
"""

[[tests]]
sql = """
MERGE dataset.DetailedInventory T
USING dataset.Inventory S
ON T.product = S.product
WHEN MATCHED AND S.quantity < (SELECT AVG(quantity) FROM dataset.Inventory) THEN
  UPDATE SET comments = ARRAY_CONCAT(comments, ARRAY<STRUCT<created DATE, comment STRING>>[(CAST('2016-02-01' AS DATE), 'comment2')])
"""

[[tests]]
sql = """
MERGE dataset.Inventory T
USING (SELECT product, quantity, state FROM dataset.NewArrivals t1 JOIN dataset.Warehouse t2 ON t1.warehouse = t2.warehouse) S
ON T.product = S.product
WHEN MATCHED AND state = 'CA' THEN
  UPDATE SET quantity = T.quantity + S.quantity
WHEN MATCHED THEN
  DELETE
"""

[[tests]]
sql = """
MERGE dataset.NewArrivals
USING (SELECT * FROM UNNEST([('microwave', 10, 'warehouse #1'),
                             ('dryer', 30, 'warehouse #1'),
                             ('oven', 20, 'warehouse #2')]))
ON FALSE
WHEN NOT MATCHED THEN
  INSERT ROW
WHEN NOT MATCHED BY SOURCE THEN
  DELETE
"""

[[tests]]
sql = """
CREATE TEMP TABLE tmp (x `decimal`(3,4), y STRUCT <a ARRAY <STRING>, b BOOL>);
"""

[[tests]]
sql = """
CREATE TEMP TABLE tmp (x string, z string,);
"""


[[tests]]
sql = """
CREATE OR REPLACE TABLE tmp (x decimal(3,4), y STRUCT <a ARRAY <STRING(255)>, b `BOOL`>);
"""

[[tests]]
sql = """
create temp table bar(x int64,primary key(x) not enforced);
create temp table foo(x int64,foreign key(x) references bar(x) not enforced,constraint `fk` foreign key(x) references bar(x) not enforced ,foreign key(x) references bar(x) not enforced);
"""

[[tests]]
sql = """
create temp table foo(primary key (x) not enforced, x int64);
create temp table bar(foreign key(x) references foo(x) not enforced, x int64) as (select 1 as x);
"""

[[tests]]
sql="""
CREATE VIEW mydataset.age_groups(age, count) AS SELECT age, COUNT(*)
FROM mydataset.people
group by age;
"""

[[tests]]
sql="""
CREATE VIEW IF NOT EXISTS`myproject.mydataset.newview`
OPTIONS(
  expiration_timestamp=TIMESTAMP_ADD(CURRENT_TIMESTAMP(), INTERVAL 48 HOUR),
  friendly_name="newview",
  description="a view that expires in 2 days",
  labels=[("org_unit", "development")]
)
AS SELECT column_1, column_2, column_3 FROM `myproject.mydataset.mytable`
"""

[[tests]]
sql="""
CREATE OR REPLACE VIEW `myproject.mydataset.newview` (
  column_1_new_name OPTIONS (DESCRIPTION='Description of the column 1 contents'),
  column_2_new_name OPTIONS (DESCRIPTION='Description of the column 2 contents'),
  column_3_new_name OPTIONS (DESCRIPTION='Description of the column 3 contents')
)
AS SELECT column_1, column_2, column_3 FROM `myproject.mydataset.mytable`
"""


[[tests]]
sql = """
DROP TABLE some_temp_table
"""

[[tests]]
sql = """
DROP TABLE IF EXISTS some_temp_table
"""

[[tests]]
sql = """
DROP TABLE proj.dat.table
"""

[[tests]]
sql = """
DECLARE x INT64;
"""

[[tests]]
sql = """
DECLARE d DATE DEFAULT CURRENT_DATE();
"""

[[tests]]
sql = """
DECLARE x, y, z INT64 DEFAULT 0;
"""

[[tests]]
sql = """
DECLARE item DEFAULT (SELECT item FROM schema1.products LIMIT 1);
"""

[[tests]]
sql = """
SET x = 5;
"""

[[tests]]
sql = """
SET (a, b, c) = (1 + 3, 'foo', false);
"""

[[tests]]
sql = """
SET @@dataset_project_id = 'MyProject';
"""

[[tests]]
sql = """
DECLARE target_word STRING DEFAULT 'methinks';
DECLARE corpus_count, word_count INT64;

SET (corpus_count, word_count) = (
  SELECT AS STRUCT COUNT(DISTINCT corpus), SUM(word_count)
  FROM bigquery-public-data.samples.shakespeare
  WHERE LOWER(word) = target_word
);
SELECT
  FORMAT('Found %d occurrences of "%s" across %d Shakespeare works',
         word_count, target_word, corpus_count) AS result;
"""

[[tests]]
sql = """
begin
exception when error then
end;
"""

[[tests]]
sql = """
l1: begin
exception when error then
end;
"""

[[tests]]
sql = """
l1: begin
exception when error then
end l1;
"""

[[tests]]
sql = """
`l1`: begin
exception when error then
end `l1`;
"""

[[tests]]
sql = """
`my.label`: begin
exception when error then
end `my.label`;
"""

[[tests]]
sql = """
begin
end;
"""

[[tests]]
sql="""
DECLARE x INT64 DEFAULT 0;
LOOP
  SET x = x + 1;
END LOOP;
"""

[[tests]]
sql="""
DECLARE x INT64 DEFAULT 0;
l1: LOOP
  SET x = x + 1;
END LOOP l1;
"""


[[tests]]
sql="""
DECLARE x INT64 DEFAULT 0;

REPEAT
  SET x = x + 1;
  SELECT x;
  UNTIL x >= 3
END REPEAT;
"""


[[tests]]
sql="""
DECLARE x INT64 DEFAULT 0;

`foo`: REPEAT
  SET x = x + 1;
  SELECT x;
  UNTIL x >= 3
END REPEAT `foo`;
"""

[[tests]]
sql="""
WHILE TRUE DO
  SELECT x;
END WHILE;
"""

[[tests]]
sql="""
`foo.bar`: WHILE TRUE DO
  SELECT x;
END WHILE `foo.bar`;
"""

[[tests]]
sql="""
label_1: BEGIN
  BREAK label_1;
END label_1;
"""

[[tests]]
sql="""
label_1: BEGIN
  LEAVE label_1;
END label_1;
"""

[[tests]]
sql="""
label_1: LOOP
  WHILE x < 1 DO
    IF y < 1 THEN
      CONTINUE label_1;
    ELSE
      BREAK label_1;
    END IF;
  END WHILE;
END LOOP label_1
"""

[[tests]]
sql="""
label_1: LOOP
  WHILE x < 1 DO
    IF y < 1 THEN
      ITERATE label_1;
    ELSE
      LEAVE label_1;
    END IF;
  END WHILE;
END LOOP label_1
"""

[[tests]]
sql="""
FOR record IN
  (SELECT word, word_count
   FROM bigquery-public-data.samples.shakespeare
   LIMIT 5)
DO
  SELECT record.word, record.word_count;
END FOR;
"""

[[tests]]
sql = """
begin
  select 1/0;
exception when error then
  select 1;
end;
"""

[[tests]]
sql = """
BEGIN

  BEGIN TRANSACTION;
  INSERT INTO mydataset.NewArrivals
    VALUES ('top load washer', 100, 'warehouse #1');
  -- Trigger an error.
  SELECT 1/0;
  COMMIT TRANSACTION;

EXCEPTION WHEN ERROR THEN
  -- Roll back the transaction inside the exception handler.
  SELECT @@error.message;
  ROLLBACK TRANSACTION;
END;
"""

[[tests]]
sql = """
DECLARE target_product_id INT64 DEFAULT 103;
IF EXISTS(SELECT 1 FROM schema.products
           WHERE product_id = target_product_id) THEN
  SELECT CONCAT('found product ', CAST(target_product_id AS STRING));
  ELSEIF EXISTS(SELECT 1 FROM schema.more_products
           WHERE product_id = target_product_id) THEN
  SELECT CONCAT('found product from more_products table',
  CAST(target_product_id AS STRING));
ELSE
  SELECT CONCAT('did not find product ', CAST(target_product_id AS STRING));
END IF;
"""

[[tests]]
sql = """
DECLARE target_product_id INT64 DEFAULT 103;
IF EXISTS(SELECT 1 FROM schema.products
           WHERE product_id = target_product_id) THEN
  SELECT CONCAT('found product ', CAST(target_product_id AS STRING));
END IF;
"""

[[tests]]
sql = """
DECLARE target_product_id INT64 DEFAULT 103;
IF EXISTS(SELECT 1 FROM schema.products
           WHERE product_id = target_product_id) THEN
  SELECT CONCAT('found product ', CAST(target_product_id AS STRING));
ELSE
  SELECT CONCAT('did not find product ', CAST(target_product_id AS STRING));
END IF;
select 1;
"""

[[tests]]
sql = """
RAISE USING MESSAGE = @@error.message;
"""


[[tests]]
sql = """
RAISE;
"""

[[tests]]
sql = """
RETURN;
"""

[[tests]]
sql = """
DECLARE retCode INT64 default 3;
CALL mySchema.UpdateSomeTables('someAccountId', retCode);
"""

[[tests]]
sql = """
DECLARE y INT64;
-- y = 1 * (3 + 2) = 5
EXECUTE IMMEDIATE "SELECT ? * (? + 2)" INTO y USING 1, 3;
"""

[[tests]]
sql = """
DECLARE book_name STRING DEFAULT 'Ulysses';
DECLARE book_year INT64 DEFAULT 1922;
DECLARE first_date INT64;

EXECUTE IMMEDIATE
  "CREATE TEMP TABLE Books (title STRING, publish_date INT64)";

EXECUTE IMMEDIATE
  "INSERT INTO Books (title, publish_date) VALUES('Hamlet', 1599)";

EXECUTE IMMEDIATE
  "INSERT INTO Books (title, publish_date) VALUES(?, ?)"
  USING book_name, book_year;

EXECUTE IMMEDIATE
  "INSERT INTO Books (title, publish_date) VALUES(@name, @year)"
  USING 1815 as year, "Emma" as name;

EXECUTE IMMEDIATE
  CONCAT(
    "INSERT INTO Books (title, publish_date)", "VALUES('Middlemarch', 1871)"
  );

EXECUTE IMMEDIATE "SELECT MIN(publish_date) FROM Books LIMIT 1" INTO first_date;
"""


[[tests]]
sql = """
DECLARE target_product_id INT64 DEFAULT 103;
CASE
  WHEN
    EXISTS(SELECT 1 FROM schema.products_a WHERE product_id = target_product_id)
    THEN SELECT 'found product in products_a table';
  WHEN
    EXISTS(SELECT 1 FROM schema.products_b WHERE product_id = target_product_id)
    THEN SELECT 'found product in products_b table';
  ELSE
    SELECT 'did not find product';
END CASE;
"""

[[tests]]
sql = """
DECLARE product_id INT64 DEFAULT 1;
CASE product_id
  WHEN 1 THEN
    SELECT CONCAT('Product one');
  WHEN 2 THEN
    SELECT CONCAT('Product two');
  ELSE
    SELECT CONCAT('Invalid product');
END CASE;
select 1;
"""
